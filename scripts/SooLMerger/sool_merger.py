#!/usr/bin/python3
#-*-coding:utf-8 -*

# ******************************************************************************
#  Copyright (c) 2018-2020 FAUCHER Julien & FRANCE Loic.                       *
#                                                                              *
#  This file is part of SooL generator.                                        *
#                                                                              *
#  SooL generator is free software: you can redistribute it and/or modify      *
#  it under the terms of the GNU Lesser General Public License                 *
#  as published by the Free Software Foundation, either version 3              *
#  of the License, or (at your option) any later version.                      *
#                                                                              *
#  SooL core Library is distributed in the hope that it will be useful,        *
#  but WITHOUT ANY WARRANTY; without even the implied warranty of              *
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the                *
#  GNU Lesser General Public License for more details.                         *
#                                                                              *
#  You should have received a copy of the GNU Lesser General Public License    *
#  along with SooL core Library. If not, see  <https://www.gnu.org/licenses/>. *
# ******************************************************************************

import argparse
import sys
from pathlib import *
from typing import *
import shutil
import os
import glob
parser = argparse.ArgumentParser(description="Simple tool to merge files generated by AnalyseHeaderST.py")


parser.add_argument("source_file",
					help="Source file to read")
parser.add_argument("dest_dir",
					help="Destination directory to write in. Should exists.")


def build_files_names(curr_file: str,dest_dir: str) -> Tuple[Path,Path,Path] :
	"""
	Generate all files paths
	:param curr_file:
	:param dest_dir:
	:return: Tuple with (struct file, def file, resulting file)
	"""
	print("\n{:#^80s}".format(" FILES NAME GENERATION "))
	if curr_file.rfind('_') == -1 :
		raise NameError("Invalid source file name " + curr_file)
	root = curr_file[:curr_file.rfind('_')]

	print("Input :")
	print("\tInput file  : ",curr_file)
	print("\tOutput dir  : ",dest_dir)
	print("Output :")
	print("\tRoot        : ",root)
	print("\tStruct file : ",root + "_struct.h")
	print("\tDef.   file : ",root + "_definition.h")
	print("\tMerged file : ",str(Path(dest_dir) / (os.path.basename(root)+ ".h")))
	
	return (Path(root + "_struct.h"),Path(root + "_definition.h"),Path(dest_dir) / (os.path.basename(root)+ ".h"))

def perform_checks(source_struct : Path,source_def : Path,dest : Path) :
	print("\n{:#^80s}".format(" FILES EXISTENCE CHECKS "))
	if not source_struct.exists() :
		raise FileNotFoundError("Input file " + str(source_struct) + " not found.")
	print("Input structure file found.")
	if not source_def.exists() :
		raise FileNotFoundError("Input file " + str(source_def) + " not found.")
	print("Input definition file found.")
	if not (dest.exists() and dest.is_dir()) :
		raise FileNotFoundError("Ouput dir " + str(dest) + " not found.")
	print("Output directory found.")
	print("\nChecks OK")

def read_input_files(files : Tuple[Path,Path]) -> Tuple[str,str]:
	print("\n{:#^80s}".format(" INPUT FILES READ "))
	output = list()
	for i in range(0,len(files)) :
		print("Reading ", files[i])
		with open(files[i],"r") as f :
			output.append(f.read())
			print("\tDone")
	
	return tuple(output)

def retrieve_tags(data : str) -> List[Tuple[str,int]] :
	tag = "//SOOL-"
	
	print("\n{:#^80s}".format(" TAG NAME RETRIEVING "))
	data_lines = data.split('\n')

	i = 1
	tag_list : List[str] = list()
	for line in data_lines :
		if tag in line :
			tag_list.append((line.strip(None),line.count("\t")))
			print("Found tag : line {:4d} - {:s}".format(i,tag_list[-1][0]))
		i += 1
	return tag_list

def get_tag_replacement(data : str, tags : Dict[str,None]) -> Dict[str,str]:
	output = dict()
	
	print("\n{:#^80s}".format(" TAG CONTENT RETRIEVING "))
	print("Retrieving : ")
	for tag in tags :
		print("\t'" + tag + "'... ",end=" ")
		beg = tag + "-BEGIN"
		end = tag + "-END"
		
		beg_id = data.find(beg)
		end_id = data.find(end)
		
		if beg_id != -1 and end_id != -1 :
			print("Done.")
			output[tag] = data[beg_id+len(beg)+1:end_id]
		else :
			print("Not found")
			output[tag] = ""
		
	return output
		
def replace_tags(data :str, tags: Dict[str,str],t_indent : Dict[str,int]) :
	print("\n{:#^80s}".format(" TAG REPLACEMENT "))
	output = data
	print("Replacing : ")
	for tag in tags :
		print("\t'" + tag + "'.")
		output= output.replace(tag,tags[tag].replace("\n","\n" + "\t" * t_indent[tag]))

	return output


runtime_args = None




if __name__ == "__main__" :
	if len(sys.argv) < 2 and runtime_args is None:
		runtime_args = ["testcase/TEST_struct.h", "testcase/output"]

	args = parser.parse_args(runtime_args)

	fileset = glob.glob(args.source_file)
	files_done = set()
	if len(fileset) > 1 :
		print("Multiple source files specifieds...")

	for source_file in fileset :

		(file_struct, file_def, dest_file) = build_files_names(source_file, args.dest_dir)
		if file_struct in files_done :
			print("\nSkipped because already done")
			print(f"{'':#^80s}\n")
			continue
		else :
			files_done.add(file_struct)

		dest_dir = Path(args.dest_dir)

		try :
			perform_checks(file_struct, file_def, dest_dir)
		except FileNotFoundError :
			print("Input file NOT found...")
			if os.path.exists(file_struct) :
				shutil.copy(file_struct,dest_file)
				print("\tStructural file found, copying file 'as is'.")
			else :
				print("\tStructural file not found. Aborting.")

		else :
			(data_struct,data_def) = read_input_files((file_struct,file_def))

			tag_struct = retrieve_tags(data_struct)

			tag_dict = dict(zip([t[0] for t in tag_struct],[None for t in tag_struct]))
			tag_indent = dict(zip([t[0] for t in tag_struct],[t[1] for t in tag_struct]))

			tag_dict = get_tag_replacement(data_def,[t[0] for t in tag_struct])

			with open(dest_file,"w+") as output :
				output.write(replace_tags(data_struct,tag_dict,tag_indent))
